
1- When infinite scrolling all the way to the bottom, multiple calls are made to the PHP page, so after you close the modal, and re-open the comments by clicking the button that triggers the comments, The line that empties the content of the comment container modal is executed. However, this request does not pass the commentsPreventMultipleCalls check in the get_comments function. Therefore, you end up with an empty container for the comments, and not a call to fill that empty container with comments, and now the last of the multiple calls made during the scroll to the bottom is on its way back from the PHP page, carrying an empty array because you had arrived at the bottom and there were no more comments to retrieve. So now, in the callback function, the conditional that is supposed to add .emptyNowPlaceholder's evaluates to true, and therefore you end up with that .emptyNowPlaceholder instead of the comments you wished to saw when you clicked the see comments button, and you are confused as hell because just 2 seconds ago you saw like 20 comments. We have fixed this by setting the commentsPreventMultipleCalls to true before we make the request and after you click the see comments button, and aborting the last of the multiple requests made during the scroll to the bottom-most comments, this second step is optional, however if you don't do it, you will end up with a useless out-of-place .emptyNowPlaceholder lying beneath the comments you are to get from the call you made by clicking the see comments button.

2- without this callback, due to the architecture of our application and our implementation of user profiles, 
whenever you were on the user-profile main screen and you opened some modals from there and then one of these 
modals ended up being a user-profile modal, when you closed all the modals, the base user-profile would be a
desolate and empty element, with no content. The following lines are supposed to address this bug.

3- This bug is detailed in a Github issue i raised to dogfalo/Materializecss (in that issue i explain 2 bugs, the latter is this supposed to be this bug).

4- this snippet extensively deals with an issue where if you hold an element and then release it, 
it won't count as a click, but we want it to count as a click, since all the apps on my S7 count a hold-release as a click.

5- In out PHP code, we run htmlspecialchars() on all our output, which will replace single quotes with an HTML entity that contains "#" character, so if we immediately called the handleTags() function on that raw value, the function would replace everything that comes after the "#" in that entity with the markup for a tag (it shouldn't do that, obviously), which will result in that entity not being loaded correctly when it is added to the page. To work around this, we add the raw values to the page first (the ones where hashtags are still just raw text), and then we run the handleTags() function on the value that has been already rendered (meaning that the "#" character is no longer there, so we won't run into the bug).